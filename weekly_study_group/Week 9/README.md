9주차 스터디
===
[난이도 하] 숫자 장식, 카드 병정의 출장
---
itertools의 product(), combinations()를 사용했습니다.  
시간이 남으면 generator로 따로 구현을 해볼 생각입니다.

<br>

[난이도 하] 재벌의 쇼핑
---
### 구현한 방법  
구간합을 이용하여 가장 작은 길이의 구간부터 하나씩 탐색하였습니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(N^2)`$, 공간복잡도: $`O(N)`$

<br>

[난이도 하] 앞면 뒷면
---
### 구현한 방법  
뒷면으로 남아있는 경우는 약수가 홀수개인 숫자에 해당할 때로 즉 그 위치의 숫자가 제곱수일 때입니다.  
math.sqrt()를 이용하여 N 이하의 자연수 중 몇 개의 제곱수가 있는지 빠르고 쉽게 구할 수 있습니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(1)`$, 공간복잡도: $`O(1)`$

<br>

[난이도 중] 자원 절약 운동
---
### 구현한 방법  
각 노드에서 BFS를 사용하여 운송 단계를 계산하고 최소인 지역을 알아냈습니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(N(N+M))`$, 공간복잡도: $`O(N)`$

<br>

[난이도 중] 큐브 미로
---
### 구현한 방법  
문제에는 DFS라고 적혀 있지만 최소 시간을 구하기 쉬운 BFS를 사용했습니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(LRC)`$, 공간복잡도: $`O(LRC)`$

<br>

[난이도 중] 스키
---
### 구현한 방법  
간단한 DP문제였습니다.  
```python
dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + data[i][j]
```
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(NM)`$, 공간복잡도: $`O(NM)`$

<br>

[난이도 상] 숫자 기차
---
### 구현한 방법  
맨 마지막칸의 숫자에 따른 경우의 수를 각각 담은 DP 2-d array를 이용하였습니다.
```python
dp[i][9] = dp[i-1][8]
dp[i][0] = dp[i-1][1]
for j in range(1, 9):
    dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1]
```
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(N)`$, 공간복잡도: $`O(N)`$

<br>

[난이도 상] 아이스크림 자판기
---
### 구현한 방법  
문제에는 이분 탐색이라고 적혀 있지만 우선순위 큐를 이용하였습니다.  
비어있는 자판기는 자판기 번호의 최소힙으로 만들고 사용중인 자판기는 사용이 끝나는 시간의 최소힙으로 만들었습니다.  
비어있는 자판기가 없을 때마다 사용중인 자판기의 최소힙에서 가장 빨리 사용이 끝나는 자판기들을 모두 비어있는 자판기로 만드는 방식입니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O((N+M)logM)`$, 공간복잡도: $`O(M)`$

<br>

[난이도 상] 끝없음
---
### 구현한 방법  
재귀함수를 이용하여 실제로 문자열을 만드는 방식으로 구현했습니다.  
다만 제한이 없이 만들다 보면 메모리를 너무 많이 잡아먹기 때문에 무조건 문자열 S의 처음이 $인 것을 이용하여 중간과정에서 만들어진 문자열의 길이가 max보다 크거나 같은 경우 재귀를 끝내서 빠르게 값을 얻을 수 있게 했습니다.
### 시간복잡도? 공간복잡도?  
시간복잡도: $`O(len(S)×max)`$, 공간복잡도: $`O(max)`$
